[阐述IEEE754转换机制](https://www.wikihow.com/Convert-a-Number-from-Decimal-to-IEEE-754-Floating-Point-Representation)
[JS双精度浮点数工作原理](https://zhuanlan.zhihu.com/p/351127362)
[JS如何来编译Number](https://2ality.com/2012/04/number-encoding.html)

在JS规范中 Number类型是统一采用 [IEEE 754 双精度64位浮点数](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) 方式来记录数值

内存结构
![内存结构](https://marz.utk.edu/wp-content/uploads/2020/04/ieee-754-64-bit-3.png)

数学公式
![数学公式1](https://wikimedia.org/api/rest_v1/media/math/render/svg/61345d47f069d645947b9c0ab676c75551f1b188)

![数学公式2](https://wikimedia.org/api/rest_v1/media/math/render/svg/30e6c59531e838bb95d404c63946f1301ac45ab3)

转换工具: [ IEEE754转换工具 - 64位 ](https://bartaz.github.io/ieee754-visualization/)

Sign: 符号位 表示正负 - 1bit位
Exponent: 指数位 - 11bit位
Fraction: 尾数位 - 52bit位 - 位数不够, 用 0 补齐, 如果超过52位 则根据 第 53 位的值决定是否要进位

转换步骤:
1 将十进制 转为 二进制 (整数和小数)
  例如: 1101.11101(二进制) = 13.90625(十进制)
2 将 二进制 通过科学计数法来标记为: 1.M * 2^e
  例如: 1.10111101 * 2^3
3 通过数学公式分别获得: Sign, Exponent, Fraction
  例如: Sign = 0, Exponent = 1026(十进制), Fraction = 10111101(二进制)
4 获得机器可识别的64位符号
  例如: 0 10000000010 10111101 0000 0000 ... 0000

示例:
``` javascript
// 十进制
let num = 6.25;

// 将 十进制 转为 二进制(整数 和 小数)
// 整数部分: 6 -> 110
// 小数部分: 0.25 -> 01

// 二进制: 110.01
// 格式化: 1.1001 0000 0000 0000 0000 0000 0000... * 2^2  小数部分共52位
// 代入数学公式得: 
// Sign: 0
// Exponent: 1025(十进制) -> 10000000001(二进制)
// Fraction: 1001 0000 0000 0000 0000 0000 0000 ... 0000
// 64位二级制 0 10000000001 1001 0000 0000 0000 0000 0000 0000 ... 0000
```

疑问1: 为什么 0.1 + 0.2 !== 0.3
我们分别将上面3个数字转化为二进制格式
```javascript
let num = 0.1
// 整数部分为0, 所以不做处理
// 小数部分: 0.1 -> 0001 1001 1001 1001 ... 1001
// 格式化: 0.0001 1001 1001 1001 ... 1001 -> 1.1001 1001 1001 ... 1010 * 2^-4


// 代入数学公式得: 
// Sign: 0
// Exponent: 1019(十进制) -> 01111111011(二进制)
// Fraction: 1001 1001 1001 ... 1001
// 64位二级制: 0 01111111011 1001 1001 1001 ... 1010
// 十进制: 2**-4 * (1 + 2**-1 + 2**-4 + 2**-5 + ... +2**-49 + 2**-51)
```

```javascript
let num = 0.2
// 整数部分为0, 所以不做处理
// 小数部分: 0.2 -> 0011 0011 0011 0011 ... 0011
// 格式化: 0.0011 0011 0011 0011 ... 0011 -> 1.1001 1001 1001 ... 1010 * 2^-3

// 代入数学公式得: 
// Sign: 0
// Exponent: 1020(十进制) -> 01111111100(二进制)
// Fraction: 1001 1001 1001 ... 1001
// 64位二级制: 0 01111111100 1001 1001 1001 ... 1010
// 十进制: 2**-3 * (1 + 2**-1 + 2**-4 + 2**-5 + ... +2**-49 + 2**-51)
```

```javascript
let num = 0.3
// 整数部分为0, 所以不做处理
// 小数部分: 0.3 -> 0100 1100 1100 1100 ... 1101
// 格式化: 0.0100 1100 1100 1100 ... 1100 -> 1.0011 0011 0011 ... 0011 * 2^-2

// 代入数学公式得: 
// Sign: 0
// Exponent: 1021(十进制) -> 01111111101(二进制)
// Fraction: 0011 0011 0011 ... 0011
// 64位二级制: 0 01111111101 0011 0011 0011 ... 0011
```

```javascript
let sum = 0.1 + 0.2
// 0.1(二进制) + 0.2(二进制)
//  0.0001 1001 1001 1001 ... 1001 1010 小数位数 52 + 4
// +0.0011 0011 0011 0011 ... 0011 010  小数位数 52 + 3
//-------------------------------------------
// =0.0100 1100 1100 1100 ... 1100 1110 小数位数 52 + 4

// 格式化:
// 1.0011 0011 0011 ... 0011 10 * 2^-2 小数部分 52 + 2(需截断)
// 由于第 53 位是1, 需要向上递补 1, 结果得:
// 1.0011 0011 0011 ... 0100 * 2^-2
// Sign: 0
// Exponent: 1021(十进制) -> 01111111101(二进制)
// Fraction: 0011 0011 0011 ... 0100
// 64位二级制: 0 01111111101 0011 0011 0011 ... 0100
```
从上面的表现来看, 通过计算得到的0.3 和 原值0.3 在二进制表现上并不一致, 所以会被认为是不相等的


疑问2: 为什么 2^53 === 2^53 + 1
``` JavaScript
/*
2^53 二进制表现形式
1 0000 0000 0000 0000 0000 ... 0000 0
1.0000 0000 0000 0000 0000 ... 0000 * 2^53 => 2^53

2^53 + 1 二进制表现形式
1 0000 0000 0000 0000 0000 ... 0000 1
1.0000 0000 0000 0000 0000 ... 0000 * 2^53 => 2^53

^53 + 2 二进制表现形式
1 0000 0000 0000 0000 0000 ... 0001 0
1.0000 0000 0000 0000 0000 ... 0001 * 2^53 => 2^53 + 2^1

^53 + 3 二进制表现形式
1 0000 0000 0000 0000 0000 ... 0001 1 (由于第53位是1, 会出现升阶现象)
1.0000 0000 0000 0000 0000 ... 0010 * 2^53  ==> 2^53 + 2^2

由于尾数长度最多是52位, 所以 2^53 和 2^53 + 1 对于计算机来说是一致的
/*
```

