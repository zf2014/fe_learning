[React揭秘](https://react.iamkasong.com/)
[React18如何工作的?](https://dev.to/ktmouk/how-does-react-18-work-inside-1c8l)
[React Fiber(纤维)&Reconciliation(协调) 工作机制](https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react)
[React Scheduler(调度器) 工作机制](https://jser.dev/react/2022/03/16/how-react-scheduler-works)

[React Lanes(车道) 工作机制](https://jser.dev/react/2022/03/26/lanes-in-react)
[React Bailout 工作机制](https://jser.dev/react/2022/01/07/how-does-bailout-work)


版本: 18.3

### React工作流程

在 React 内部会通过内置的 Scheduler, 及根据四种不同的策略, 将渲染任务划分成不同优先级的任务, 并且这些任务会根据其策略依次触发

渲染 -> [Task1, Task2, ... TaskN] -> 任务列表是可变的

这里的Task是指, 触发React渲染入口, 具体在React内部, 又分为同步渲染 和 异步渲染

如果是异步任务, 会个根据最小帧数(5ms), 将单个Task拆分为 N 个可持续任务(可被打断), 如果在执行这些任务过程中, 动态插入了优先级更高的任务时, 此时会优先执行优先级高的任务, 即中断当前任务, 当高优先级任务执行完成后, 又会恢复执行之前被中断的任务

在React内部, render 阶段可分为同步和异步, 在该阶段中, 会比较前后2个Fiber节点树差异, 并且根据比较结果, 在 commit 阶段(同步), 完成特定行为, 并且完成DOM渲染

---------

1. 根据容器元素, 创建 FiberRootNode
2. 创建 RootFiber, tag 为 HostRoot
3. 根据 传入的根节点(App), 开启协调流程(Reconciliation) - 触发 scheduleUpdateOnFiber 方法
4. 确定 lane, 确定任务优先级 以及 渲染模式(同步/异步)
5. 协调过程可分为2个阶段: Render 和 Commit
6. 在 Render 阶段, 会依次将节点结构 转为 Fiber结构
7. 在 Commit 阶段, 又会每个 Fiber 节点上的 flags 信息, 执行不同类型的Effect, 大致可分为:
Before Mutation(渲染前) | Mutation(渲染中) | Layout(渲染后) | Passive Effect(下一帧)

在模块 ReactFiberCommitWork.js 中:

Before Mutation:
Function Component: 改变 useEffectEvent 中绑定的回调函数
Class Component: 触发 getSnapshotBeforeUpdate

Mutation: - 根据 Fiber 节点的 flags 属性, 执行增 删 改 查等操作
Class Component: 触发 componentWillUnmount 生命周期
Function Component: 触发 effect destroy 函数
Host Component: DOM元素的增删改

Layout: 
条件:
fiber.return.subtreeFlags 包含 LayoutMask(Update | Callback | Ref | Visibility)
执行 Class Component 的 componentDidMount 生命周期
设置 Ref 数据
等等

Passive Effect: 执行 Mount 和 UnMount Effect
条件:
fiber.flags 包含 Passive 且
fiber.updateQueue 队列中 effect.tag === HookPassive | HookHasEffect 副作用(Mount 和  UnMount)


-----

后续需要重新渲染, 则可以通过 scheduleUpdateOnFiber 方法, 根据传入的参数不同, 渲染方式也将会有所差异


### Reconciliation
React通过该算法, 将组件转换为Fiber树, Fiber节点间关系通过: child(子), return(父), sibling(兄弟) 建立关系. 同时会维护2棵Fiber树: current(当前渲染树) 和 workInProcess(等待渲染树), 并且在各自节点上, 通过 alternate 属性相互引用. 整个过程又分为2个阶段: render 和 commit

render阶段(异步): 构建 workInProcess 树, 并且会在各个节点上标记相应的 Effect 行为
commit阶段(同步): workInProcess 树 转为 current 树, 并且执行 Effect 行为(Before Mount/ Mount / Layout)


### Bailout
当React组件的props或state没有发生变化时，React会使用先前渲染的结果来更新组件，而不会重新渲染整个组件。这个过程被称为"bailout"，因为React会在渲染过程中"放弃"对组件的重新渲染。

### 关键文件
- ReactFiberRootScheduler.js // 封装的任务调度器
- ReactFiberReconciler.js // Fiber协调器
- ReactFiberWorkLoop.js // 构建Fiber树(render阶段)
- ReactFiberBeginWork.js // 构建Fiber树(render阶段)
- ReactFiberCompleteWork.js // 构建Fiber树(render阶段)
- ReactFiberCommitWork.js // 构建完Fiber树, 开始执行不同Effect(commit阶段)
- ReactChildFiber.js // 创建和维护Fiber节点
- ReactFiberHooks.js // 钩子函数定义


```js
export type Fiber = {

  // 用于描述Fiber数据
  tag: WorkTag, // 划分组件形式
  key: null | string, // 关键属性(可用于表示唯一性)
  elementType: any, // 通常和 type 一致
  type: any, // 组件初始形态(Function/Class/...)
  stateNode: any, // 表示Fiber节点实例(如果是Class组件, 则表示组件对象, 如果是DOM组件, 则表示DOM对象, 如果是Function组件, 则为 null)

  // 用于Fiber结构
  return: Fiber | null, // 父Fiber
  child: Fiber | null, // 子Fiber
  sibling: Fiber | null, // 兄弟Fiber

  index: number,

  ref, // ref 引用
  refCleanup, // 清理Ref方法

  pendingProps: any, // 传入props(新)
  memoizedProps: any, // 当前props值(旧)

  updateQueue: mixed, // 更新队列

  memoizedState: any, // 组件状态

  dependencies: Dependencies | null, // 用于记录Context数据

  mode: TypeOfMode, // Fiber模式

  flags: Flags, // 行为标记 -> 用于明确当前Fiber将要执行的Effect
  subtreeFlags: Flags, // 合计所有子Fiber的Flags数据
  deletions: Array<Fiber> | null, // 记录待删除的Fiber集合

  nextEffect: Fiber | null,

  firstEffect: Fiber | null,
  lastEffect: Fiber | null,

  lanes: Lanes, // 优先级
  childLanes: Lanes, // 合计子Fiber的优先级

  alternate: Fiber | null, // Current Fiber 和 workInProcess Fiber

  actualDuration?: number,

  actualStartTime?: number,

  selfBaseDuration?: number,

  treeBaseDuration?: number,


  _debugSource?: Source | null,
  _debugOwner?: Fiber | null,
  _debugIsCurrentlyTiming?: boolean,
  _debugNeedsRemount?: boolean,
  _debugHookTypes?: Array<HookType> | null,
};

```

### 解读hooks
核心模块 ReactFiberHooks.js

由于React内部, 在处理 FunctionComponent 时, 会通过 renderWithHooks 方法来适配不同的 Dispatcher 对象, 从而保证相同的API提供不同的实现方式.

两种 Dispatcher 对象: HooksDispatcherOnMount 和 HooksDispatcherOnUpdate

从命名上可以得知, 主要是用于区分 Mount 和 Update 两种状态, 即在首次构建时, 会使用 HooksDispatcherOnMount 定义的方案, 其他情况使用 HooksDispatcherOnUpdate 方案

#### 解读 useState 钩子函数
在 ReactFiberHooks 模块内, 分别定义了 mountState 和 updateState

``` js
let [state, setState] = useState(initValue)
```

Mount 阶段:
执行 mountWorkInProgressHook 方法, 创建hook对象, 并且 fiber.memoizedState = hook
如果组件内调用多次 mountWorkInProgressHook, 则会通过链式的方式保存: 
格式: fiber.memoizedState = hook1.next = ... = hookM.next = hookN
每个 hook 的结构:
```js
const hook: Hook = {
  memoizedState, // 当前状态值
  baseState, // 上次状态值
  baseQueue,
  queue,
  next,
}
```
如果在调用 useState 传入了 初始数据, 则会把该初始数据记录在 hook.memoizedState 和  hook.baseState
同时会创建一个 dispatch 方法, 并记录在 hook.queue.dispatch, 该 dispatch 方法实际上是模块中定义的 dispatchSetState 方法
最终返回 [hook.memoizedState,  dispatch]


Update 阶段:
由于某种交互的需求, 需要修改状态, 即调用 dispatch 方法, 也即调用 dispatchSetState 方法
在 dispatchSetState 内部:
1. 先获取一个 lane 值, 来确定再次渲染的优先级
2. 创建一个 Update 对象, 用于记录该变更行为 action
3. 如果执行setState发生在 Render 阶段: -- 即在执行 useState(...) 后, 即刻执行 setState(...)
4. 追加 hook.queue.pending 数据链
5. 标记 didScheduleRenderPhaseUpdateDuringThisPass 为 true
6. 当Function组件执行完成后, 执行 renderWithHooksAgain, 再次触发一次Function组件的调用(React内部有限制, 默认允许25次)

7. 如果执行setState发生在 非Render 阶段: -- 在渲染完成后, 通过用户交互来触发 setState(...)
8. 则会把 Update, hook.queue, Fiber 和 lane 暂时存在 concurrentQueues 中
9. 通知 React 任务调度器安排重新渲染
10. 从 concurrentQueues 中依次读取出相关数据, 并建立 queue.pending = update.next = ... = updateN.next = update 链式关系
11. 修改 fiber 对象中的lanes 和 childLanes 
12. 进入 React 协调阶段
13. 再次执行 useState(...)方法, 此时将会调用模块内的 updateState 方法:
14. 从 hook.queue.pending 中获取 update, 依次执行 update.action, 最终得到新的状态值
15. 将新的状态值赋予 hook.memoizedState 和 hook.baseState
16. 返回 [hook.memoizedState,  dispatch]
